<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Huntington Election Map Template</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Simple upload box */
    .upload-box {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 9999;
      background: rgba(255,255,255,0.95);
      padding: 12px 14px;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      width: 320px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .upload-box h2 {
      margin: 0 0 6px 0;
      font-size: 22px;
      line-height: 1.1;
    }
    .upload-box .help {
      font-size: 13px;
      margin-top: 6px;
      color: #222;
      white-space: pre-line;
    }

    /* Popup table */
    .popup-table {
      border-collapse: collapse;
      width: 100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-size: 14px;
    }
    .popup-table td {
      padding: 6px 8px;
      border-bottom: 1px solid rgba(0,0,0,0.12);
      vertical-align: top;
    }
    .popup-table td.key {
      font-weight: 600;
      white-space: nowrap;
    }
  </style>
</head>

<body>
  <div class="upload-box">
    <h2>Upload CSV</h2>
    <input type="file" id="csvInput" accept=".csv" />
    <div class="help">Must include column Committee Members.
Optional: Highlight (put X to show).</div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- PapaParse for CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Turf for centroid/area -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script>
    // ---------------------------
    // Map setup
    // ---------------------------
    const map = L.map('map').setView([40.85, -73.4], 10);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // ---------------------------
    // Load your GeoJSON (update this path if needed)
    // ---------------------------
    // This expects a GeoJSON in the same repo folder, e.g., "huntington_ed.geojson".
    // If you already have a different filename, change it here.
    const GEOJSON_PATH = "huntington_ed.geojson";

    let geoLayer = null;
    let geoJsonData = null;

    fetch(GEOJSON_PATH)
      .then(r => r.json())
      .then(data => {
        geoJsonData = data;
        geoLayer = L.geoJSON(geoJsonData, {
          style: featureStyle,
          onEachFeature
        }).addTo(map);
        map.fitBounds(geoLayer.getBounds());
      })
      .catch(err => console.error("GeoJSON load error:", err));

    // ---------------------------
    // CSV normalization helpers
    // ---------------------------

    // Canonical names used internally and shown in the popup (per your request)
    const CANON = {
      OPP_VOTES: "Opposition Candidate Votes",
      OPP_PCT: "Opposition Candidate Percentage of Votes",
      GOP_VOTES: "GOP Candidate Vote Count",
      GOP_PCT: "GOP Candidate Percentage of Votes",

      // Existing fields already used in your popup/screenshot
      PCT_DIFF: "Percent Difference",
      TOTAL: "Total Votes"
    };

    // Map any incoming header variants (old/new) to the canonical popup labels
    const HEADER_ALIASES = {
      // Your new CSV headers â†’ your requested popup labels
      "Opposition Vote Count(A+B)": CANON.OPP_VOTES,
      "Opposition Percentage (A+B)": CANON.OPP_PCT,
      "Republican Vote Count (C+D)": CANON.GOP_VOTES,
      "Republican  Percentage (C+D)": CANON.GOP_PCT,

      // Common variants / previous versions (so old CSVs still work)
      "Opposition Vote Count (A+B)": CANON.OPP_VOTES,
      "Opposition Percentage(A+B)": CANON.OPP_PCT,
      "Opposition % (A+B)": CANON.OPP_PCT,
      "Opposition Candidate Votes": CANON.OPP_VOTES,
      "Opposition Candidate Vote Count": CANON.OPP_VOTES,
      "Opposition Candidate Percent": CANON.OPP_PCT,
      "Opposition Candidate Percentage": CANON.OPP_PCT,
      "Opposition Candidate Percentage of Votes": CANON.OPP_PCT,

      "GOP Candidate Votes": CANON.GOP_VOTES,
      "GOP Vote Count": CANON.GOP_VOTES,
      "Republican Candidate Votes": CANON.GOP_VOTES,
      "Republican Vote Count": CANON.GOP_VOTES,
      "GOP Candidate Vote Count": CANON.GOP_VOTES,

      "GOP Candidate Percent": CANON.GOP_PCT,
      "GOP Candidate Percentage": CANON.GOP_PCT,
      "GOP Candidate Percentage of Votes": CANON.GOP_PCT,
      "Republican Candidate Percent": CANON.GOP_PCT,
      "Republican Percentage": CANON.GOP_PCT,

      // Existing popup fields
      "Percent Difference": CANON.PCT_DIFF,
      "Total Votes": CANON.TOTAL
    };

    // Parse "44.30%" / "44.30" / "0.443" -> percent number (0-100)
    function parsePercentLike(v) {
      if (v === null || v === undefined) return null;
      const s = String(v).trim();
      if (!s) return null;

      if (s.endsWith("%")) {
        const n = Number(s.replace("%", "").trim());
        return Number.isFinite(n) ? n : null;
      }
      const n = Number(s);
      if (!Number.isFinite(n)) return null;

      // If it's between 0 and 1, assume it's a fraction
      if (n >= 0 && n <= 1) return n * 100;
      return n; // already percent-like
    }

    function formatPercent(v) {
      const n = parsePercentLike(v);
      if (n === null) return "";
      return n.toFixed(2) + "%";
    }

    function parseNumber(v) {
      if (v === null || v === undefined) return null;
      const s = String(v).replace(/,/g, "").trim();
      if (!s) return null;
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    }

    function formatInt(v) {
      const n = parseNumber(v);
      if (n === null) return "";
      return Math.round(n).toString();
    }

    // ---------------------------
    // CSV upload + join
    // ---------------------------
    // You must have an ID column in both geojson and csv.
    // This template uses "ED" as the feature key by default.
    // Change these if your data uses something else.
    const FEATURE_KEY = "ED";   // property name in GeoJSON
    const CSV_KEY = "ED";       // column in CSV

    document.getElementById("csvInput").addEventListener("change", (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          const rows = results.data || [];
          const lookup = new Map();

          for (const row of rows) {
            const rawId = row[CSV_KEY];
            if (rawId === undefined || rawId === null) continue;
            const id = String(rawId).trim();
            if (!id) continue;

            // Build a normalized object keyed by canonical names
            const normalized = {};
            for (const [rawHeader, rawValue] of Object.entries(row)) {
              const header = String(rawHeader).trim();
              const mapped = HEADER_ALIASES[header] || header;

              // Store raw, then format later in popup for specific keys
              normalized[mapped] = rawValue;
            }
            // Always keep the ID too
            normalized[CSV_KEY] = id;
            lookup.set(id, normalized);
          }

          // Join to geojson features
          if (!geoJsonData) return;

          for (const f of geoJsonData.features) {
            const fid = String(f.properties?.[FEATURE_KEY] ?? "").trim();
            if (!fid) continue;

            const match = lookup.get(fid);
            if (match) {
              f.properties = { ...f.properties, ...match };
            }
          }

          // Refresh layer
          if (geoLayer) geoLayer.remove();
          geoLayer = L.geoJSON(geoJsonData, {
            style: featureStyle,
            onEachFeature
          }).addTo(map);
        }
      });
    });

    // ---------------------------
    // Styling (simple choropleth by Percent Difference if present)
    // ---------------------------
    function getFillColor(feature) {
      const v = parseNumber(feature.properties?.[CANON.PCT_DIFF]);
      if (v === null) return "#cccccc";

      // simple diverging-ish thresholds using absolute value
      const abs = Math.abs(v);
      if (abs >= 20) return "#7f0000";
      if (abs >= 10) return "#b30000";
      if (abs >= 5)  return "#d7301f";
      if (abs >= 2)  return "#fc8d59";
      return "#fdd49e";
    }

    function featureStyle(feature) {
      return {
        weight: 1,
        color: "#222",
        fillOpacity: 0.55,
        fillColor: getFillColor(feature)
      };
    }

    // ---------------------------
    // Popups
    // ---------------------------
    const POPUP_FIELDS = [
      // these are your requested 4 fields
      CANON.OPP_VOTES,
      CANON.OPP_PCT,
      CANON.GOP_VOTES,
      CANON.GOP_PCT,

      // existing fields from your screenshot (keep if present)
      CANON.PCT_DIFF,
      CANON.TOTAL
    ];

    function valueForPopup(key, rawValue) {
      if (rawValue === null || rawValue === undefined) return "";

      // Keep 0 values visible
      const s = String(rawValue).trim();
      if (s === "") return "";

      if (key === CANON.OPP_PCT || key === CANON.GOP_PCT) return formatPercent(rawValue);
      if (key === CANON.OPP_VOTES || key === CANON.GOP_VOTES || key === CANON.TOTAL) return formatInt(rawValue);

      // percent difference could be percent or number; format as percent if it looks like one
      if (key === CANON.PCT_DIFF) {
        const n = parseNumber(rawValue);
        if (n === null) return s;
        return n.toFixed(2) + "%";
      }

      return s;
    }

    function popupHtml(props) {
      let html = `<table class="popup-table">`;

      // Always show ED if present
      if (props?.[FEATURE_KEY] !== undefined) {
        html += `<tr><td class="key">${FEATURE_KEY}</td><td>${String(props[FEATURE_KEY])}</td></tr>`;
      }

      for (const key of POPUP_FIELDS) {
        if (!(key in props)) continue; // only show if present
        const displayVal = valueForPopup(key, props[key]);
        if (displayVal === "") continue;
        html += `<tr><td class="key">${key}</td><td>${displayVal}</td></tr>`;
      }

      html += `</table>`;
      return html;
    }

    function onEachFeature(feature, layer) {
      layer.on({
        click: () => {
          const props = feature.properties || {};
          layer.bindPopup(popupHtml(props), { maxWidth: 360 }).openPopup();
        }
      });
    }
  </script>
</body>
</html>
